"""
This type stub file was generated by pyright.
"""

from functools import lru_cache

def get_template_pack(): # -> Any | str:
    ...

TEMPLATE_PACK = ...
@lru_cache()
def default_field_template(template_pack=...): # -> _BaseTemplate:
    ...

def render_field(field, form, form_style, context, template=..., labelclass=..., layout_object=..., attrs=..., template_pack=..., extra_context=..., **kwargs):
    """
    Renders a django-crispy-forms field

    :param field: Can be a string or a Layout object like `Row`. If it's a layout
        object, we call its render method, otherwise we instantiate a BoundField
        and render it using default template 'CRISPY_TEMPLATE_PACK/field.html'
        The field is added to a list that the form holds called `rendered_fields`
        to avoid double rendering fields.
    :param form: The form/formset to which that field belongs to.
    :param form_style: A way to pass style name to the CSS framework used.
    :template: Template used for rendering the field.
    :layout_object: If passed, it points to the Layout object that is being rendered.
        We use it to store its bound fields in a list called `layout_object.bound_fields`
    :attrs: Attributes for the field's widget
    :template_pack: Name of the template pack to be used for rendering `field`
    :extra_context: Dictionary to be added to context, added variables by the layout object
    """
    ...

def flatatt(attrs): # -> SafeText:
    """
    Convert a dictionary of attributes to a single string.

    Passed attributes are redirected to `django.forms.utils.flatatt()`
    with replaced "_" (underscores) by "-" (dashes) in their names.
    """
    ...

def render_crispy_form(form, helper=..., context=...): # -> SafeText | str:
    """
    Renders a form and returns its HTML output.

    This function wraps the template logic in a function easy to use in a Django view.
    """
    ...

def list_intersection(list1, list2): # -> list[Any]:
    """
    Take the not-in-place intersection of two lists, similar to sets but preserving order.
    Does not check unicity of list1.
    """
    ...

def list_difference(left, right): # -> list[Any]:
    """
    Take the not-in-place difference of two lists (left - right), similar to sets but preserving order.
    """
    ...

